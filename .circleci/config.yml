version: 2

# First we will define the jobs that are used in the workflows.
# 
# Workflows can be found at the bottom of this file.  They specify
# what order the jobs run in and what depends on what.
jobs: 

  gcp_setup:
    docker:
      - image: google/cloud-sdk
    steps:
      - checkout
      - run: &set-gcp-init-vars  #Create the service account json file for authentication,and set the project id from CircleCI variables..
          name: set up job variables and key
          command: |
            echo $(env | grep -E "^GCLOUD_SERVICE_KEY_${CIRCLE_BRANCH}=" | sed "s/^GCLOUD_SERVICE_KEY_${CIRCLE_BRANCH}=//") > ${HOME}/gcloud-service-key.json
            export GOOGLE_PROJECT_ID=$(env | awk -F= "/^GOOGLE_PROJECT_ID_${CIRCLE_BRANCH}=/ {print \$2}")
            echo "export GOOGLE_PROJECT_ID='$GOOGLE_PROJECT_ID'" >> $BASH_ENV
      - run: &install-gcp-sdk-nongoogle   #Install the Google Clound SDK if it is required.  None google/cloud-sdk images will most likely require this.
          name: Setup Google Cloud SDK
          command: |   
            echo "Installing Google Cloud SDK..."        
            if hash gcloud 2>/dev/null
            then
              echo "Google Cloud already installed..."
            else
              export GCLOUD_SDK_VERSION=258
              curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-$GCLOUD_SDK_VERSION.0.0-linux-x86_64.tar.gz -o ./gcloud-sdk.tar.gz
              tar xzf gcloud-sdk.tar.gz -C ~
              rm gcloud-sdk.tar.gz
              export PATH=~/google-cloud-sdk/bin:$PATH
              echo 'export PATH=~/google-cloud-sdk/bin:$PATH' >> $BASH_ENV
              source $BASH_ENV              
            fi
      - run: &initgcp-sdk #Authenticate using service account and configure the default project
          name: Initialize Google Cloud SDK
          command: |
            gcloud auth activate-service-account --key-file ${HOME}/gcloud-service-key.json
            gcloud config set project $GOOGLE_PROJECT_ID
      - run: &getvars #Pull the secrets file for this project and decrypt it.
          name: Download and decrypt secrets file
          command: |
            cd gcp_setup_secrets/
            mkdir /tmp/workspace || true
            ./gcp_setup_secrets.sh --project-id=$GOOGLE_PROJECT_ID --environment=${CIRCLE_BRANCH} --secrets-file=/tmp/workspace/vars.json --decrypt=true
      - run: 
          name: Install jq for parsing secrets file in the loadvars task
          command: apt-get install jq -y                
      - run: &loadvars #Load the secrets file as environment variables.
          name: Load secrets into environment variables
          command: |
            OLDIFS="$IFS"
            IFS=$'\n'
            export SECRETS_FILE="/tmp/workspace/vars.json"
            for env_var in $(jq 'to_entries|map("\(.key)='"'"'\(.value|tostring)'"'"'")|.[]' $SECRETS_FILE | sed -e 's/^"//' -e 's/"$//' )
            do
              echo "export $env_var" >> $BASH_ENV
              export $env_var
            done  
            IFS="$OLDIFS"
            . "${BASH_ENV}"
      - persist_to_workspace:  #Save the decrypted secrets to vars.json and persist between jobs
          root: /tmp/workspace
          paths: 
            - vars.json

  init_terraform_state:
    docker:
      - image: google/cloud-sdk
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - run: 
          <<: *set-gcp-init-vars
      - run:
          <<: *initgcp-sdk
      - run:
          name: create terraform state bucket
          command: |
            gsutil mb gs://gcp-terraform-state-$GOOGLE_PROJECT_ID || true

  plan_terraform:
    docker:
      - image: hashicorp/terraform:0.11.13
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - checkout
      - run:
          <<: *set-gcp-init-vars
      - run: 
          name: Install jq for parsing secrets file
          command: apk add -U --no-cache jq
      - run:  #Load variables
          <<: *loadvars
      - run:
          name: Initialize and plan Terraform (check plan out here before approving!)
          command: |
            #Load CIRCLE  environment variables as bash environment variables
            . "${BASH_ENV}"
            export TF_VAR_project_id=${GOOGLE_PROJECT_ID}
            export TF_VAR_environment=${CIRCLE_BRANCH}
            export TF_VAR_cloudsql_username="$CLOUDSQL_USERNAME"
            export TF_VAR_cloudsql_password="$CLOUDSQL_PASSWORD"
            cd terraform && terraform init -backend-config="bucket=gcp-terraform-state-${GOOGLE_PROJECT_ID}" && terraform plan -input=false

  apply_terraform:
    docker:
      - image: hashicorp/terraform:0.11.13
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - checkout
      - run:  #Set
          <<: *set-gcp-init-vars
      - run: 
          name: Install jq for parsing secrets file in the loadvars task
          command: apk add -U --no-cache jq
      - run:  #Load variables
          <<: *loadvars
      - run:
          name: Apply Terraform
          command: |
            #Load CIRCLE  environment variables as bash environment variables
            . "${BASH_ENV}"
            export TF_VAR_project_id=${GOOGLE_PROJECT_ID}
            export TF_VAR_environment=${CIRCLE_BRANCH}
            export TF_VAR_cloudsql_username="$CLOUDSQL_USERNAME"
            export TF_VAR_cloudsql_password="$CLOUDSQL_PASSWORD"          
            cd terraform && terraform init -backend-config="bucket=gcp-terraform-state-${GOOGLE_PROJECT_ID}" && terraform apply -input=false -auto-approve
 
  deploy-py-postgres:
    docker:
      - image: google/cloud-sdk

    steps:
      - attach_workspace:
          at: /tmp/workspace
      - checkout
      - run:
          <<: *set-gcp-init-vars
      - run:
          <<: *initgcp-sdk
      - run: 
          name: Install jq for parsing secrets file in the loadvars task
          command: apt-get install jq -y         
      - run:  #Load decrypted variables
          <<: *loadvars
      - run:
          name: prepare app engine config, deploy, and run db migrations
          no_output_timeout: 20m
          command: |

            #Load CIRCLE  environment variables as bash environment variables
            . "${BASH_ENV}" 

            #Set the application name
            export APP_NAME="py-postgres"

            #Set the number of intial instances to start to support the application.
            if [ "${CIRCLE_BRANCH}" = "master" ] ; then
              export INSTANCES=2
            else
              export RAILS_ENV=${CIRCLE_BRANCH}
              export INSTANCES=1
            fi
            #export PROXY_URL="https://${GOOGLE_PROJECT_ID}.appspot.com/"
            export CONNECTION_NAME="${GOOGLE_PROJECT_ID}:us-east1:postgres"

            #Run the database setup script
            #This process is a little involved as we must first setup a SQL proxy and python development environment to run the neccessary scripts.

            #Install all prereqs required to run the table create script.
            echo "Installing prereqs..."
            pip install -r cloudsql_postgresql/requirements.txt
            #Setup the Cloud SQL proxy.
            echo "Setup the sql proxy..."
            #Set the SQLALCHEMY_DATABASE_URI as required for local connections to the cloud_sql_proxy.
            export SQLALCHEMY_DATABASE_URI="postgresql+psycopg2://${CLOUDSQL_USERNAME}:${CLOUDSQL_PASSWORD}@127.0.0.1:5432/postgres"            
            echo $(env | grep -E "^GCLOUD_SERVICE_KEY_${CIRCLE_BRANCH}=" | sed "s/^GCLOUD_SERVICE_KEY_${CIRCLE_BRANCH}=//") > ${HOME}/gcloud-service-key.json
            curl https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -o ./cloud_sql_proxy
            chmod 750 ./cloud_sql_proxy
            ./cloud_sql_proxy -instances=$CONNECTION_NAME=tcp:5432 -credential_file=${HOME}/gcloud-service-key.json & 
            #Create the tables
            echo "Running table creation script..."
            python cloudsql_postgresql/create_tables.py | true 
            echo "Generating app.yml for application..."

            #Create the app.yml that describes this application.
            #Pay special notice to the SQLALCHEMY_DATABASE_URI required to allow the Appengine service to connect to the database.
            cat <<EOF > cloudsql_postgresql/app.yaml
            runtime: python
            env: flex
            service: ${APP_NAME}
            automatic_scaling:
              min_num_instances: ${INSTANCES}            
            entrypoint: gunicorn -b :8080 main:app

            runtime_config:
              python_version: 3

            #[START gae_flex_postgres_env]
            env_variables:
                # Replace user, password, database, and instance connection name with the values obtained
                # when configuring your Cloud SQL instance.
                SQLALCHEMY_DATABASE_URI: >-
                  postgresql+psycopg2://${CLOUDSQL_USERNAME}:${CLOUDSQL_PASSWORD}@/postgres?host=/cloudsql/${CONNECTION_NAME}

            #[END gae_flex_postgres_env]

            #[START gae_flex_postgres_settings]
            # Replace project and instance with the values obtained  when configuring your
            # Cloud SQL instance.
            beta_settings:
                cloud_sql_instances: "${CONNECTION_NAME}"
            #[END gae_flex_postgres_settings]
            EOF
            
            #Start the actual deployment process
            cd cloudsql_postgresql
            #Deploy app and save output to json file for later parsing
            gcloud app deploy -q --no-promote --format=json > /tmp/${APP_NAME}.json
            #Record the application version number and store it 
            cat /tmp/${APP_NAME}.json | jq -r .versions[0].id > /tmp/workspace/${APP_NAME}-version
            export TARGET_VERSION=$(cat /tmp/workspace/${APP_NAME}-version)
            # Store signature key and URL so that we can test it later on.
            echo "https://${TARGET_VERSION}-dot-${APP_NAME}-dot-${GOOGLE_PROJECT_ID}.appspot.com/" > /tmp/workspace/${APP_NAME}-url

      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - py-postgres-version
            - py-postgres-url

  test-py-postgres:
    docker:
      - image: google/cloud-sdk
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Test the app!
          command: |
            echo "run tests here against $(cat /tmp/workspace/py-postgres-url) with an ${AUTH_HEADER} header"


  owaspzap-py-postgres:
    docker:
      - image: owasp/zap2docker-weekly
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Run OWASP Zap against the app! (fails if the test takes more than 30 minutes)
          no_output_timeout: 30m
          command: |
            #Set the application name
            export APP_NAME="py-postgres"

            # if we are in production, do not do form posts, because they can potentially create cruft in the db.
            if [ "${CIRCLE_BRANCH}" = "master" ] ; then
              POSTFORM=false
            else
              POSTFORM=true
            fi
            export ZAP_CONFIG=" \
              -config globalexcludeurl.url_list.url\(0\).regex='.*/robots\.txt.*' \
              -config globalexcludeurl.url_list.url\(0\).description='Exclude robots.txt' \
              -config globalexcludeurl.url_list.url\(0\).enabled=true \
              -config spider.postform=${POSTFORM}"
            if zap-full-scan.py -m 5 -z "${ZAP_CONFIG}" -t "$(cat  /tmp/workspace/${APP_NAME}-url)" ; then
              echo "OWASP ZAP scan found no problems.  Yay!"
            else
              echo "XXX run a script or send email to notify Admins that the OWASP ZAP scan found issues here"
            fi


  promote-py-postgres:
    docker:
      - image: google/cloud-sdk
        environment:
          APP_NAME: py-postgres      
    steps:
      - run:
          <<: *set-gcp-init-vars
      - run:
          <<: *initgcp-sdk
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Promote ${APP_NAME}
          command: |
            # promote application
            export VERSION=$(cat /tmp/workspace/${APP_NAME}-version)
            gcloud app services set-traffic ${APP_NAME} --splits ${VERSION}=1 --quiet
            echo promoted ${APP_NAME} ${VERSION} to "https://${APP_NAME}-${GOOGLE_PROJECT_ID}.appspot.com/"
      - run:
          name: Clean up old versions
          no_output_timeout: 30m
          command: |
            # clean up old versions (leave the last two, so you can roll back)
            VERSIONS=$(gcloud app versions list --service=${APP_NAME} --format=list | sort -rn | tail -n +3 | sed 's/^.*\///') || true
            if [ ! -z "${VERSIONS}" ] ; then
              gcloud app versions delete --service=${APP_NAME} ${VERSIONS} --quiet || true
              echo cleaned up ${APP_NAME} ${VERSIONS}
            else
              echo no ${APP_NAME} versions to clean up
            fi


  deploy-rails:
    docker:
      - image: circleci/ruby:2.5.3-stretch
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "rails-example/Gemfile.lock" }}
            - v1-dependencies-
      - run:
          name: Install Ruby dependencies
          command: |
            cd rails-example
            BUNDLER_VERSION=$(cat Gemfile.lock | tail -1 | tr -d " ") gem install bundler
            bundle check || bundle install --deployment
      - save_cache:
          key: v1-dependencies-{{ checksum "rails-example/Gemfile.lock" }}
          paths:
            - rails-example/vendor/bundle
      - run:
          <<: *set-gcp-init-vars
      - run:
          <<: *install-gcp-sdk-nongoogle
      - run:
          <<: *initgcp-sdk          
      - run:  #Load decrypted variables
          <<: *loadvars
      - run:
          name: create an empty default app if needed for bootstrapping
          no_output_timeout: 20m
          command: |
            if gcloud app versions list --service=default --format=text >/dev/null 2>&1 ; then
              echo default app already set up
            else
              echo ===================================================
              echo seeding project with a default app so that the other versions can deploy
              echo this should only happen once, while you are bootstrapping the environment
              echo and it should go away once the real default app is deployed.
              echo This is needed because you must deploy a default service before you
              echo deploy any other service.
              echo ===================================================
              git clone https://github.com/GoogleCloudPlatform/ruby-docs-samples
              cd ruby-docs-samples/appengine/hello_world
              bundle install
              gcloud app deploy -q --no-promote
            fi
      - run:
          name: prepare app engine config, deploy, and run db migrations
          no_output_timeout: 20m
          command: |
            #Load CIRCLE  environment variables as bash environment variables
            . "${BASH_ENV}"
            #Set the number of intial instances to start to support the application.
            if [ "${CIRCLE_BRANCH}" = "master" ] ; then
              export RAILS_ENV=production
              export INSTANCES=2
            else
              export RAILS_ENV=${CIRCLE_BRANCH}
              export INSTANCES=1
            fi
            export PROXY_URL="https://${GOOGLE_PROJECT_ID}.appspot.com/"
            export CONNECTION_NAME="${GOOGLE_PROJECT_ID}:us-east1:postgres"
            cat <<EOF > rails-example/app.yaml
            runtime: ruby
            env: flex
            service: rails
            automatic_scaling:
              min_num_instances: ${INSTANCES}
            env_variables:
              SECRET_KEY_BASE: "${SECRET_KEY_BASE}"
              CLOUDSQL_USERNAME: "${CLOUDSQL_USERNAME}"
              CLOUDSQL_PASSWORD: "${CLOUDSQL_PASSWORD}"
              CLOUDSQL_INSTANCE: "${CONNECTION_NAME}"
              SIGNATURE_KEY: "${SIGNATURE_KEY}"
              RAILS_ENV: "${RAILS_ENV}"
              BASICAUTH_PASSWORD: "${BASICAUTH_PASSWORD}"
              BASICAUTH_USER: "${BASICAUTH_USER}"
              IDP_PROVIDER_URL: "${IDP_PROVIDER_URL}"
              RAILS_LOG_TO_STDOUT: True
              RAILS_SERVE_STATIC_FILES: True
              RAILS_LOG_HEADERS: True
              PROXY_URL: "${PROXY_URL}"
            beta_settings:
              cloud_sql_instances: ${CONNECTION_NAME}
            EOF

            # do the deploy!  Store the version so that we can promote it later.
            cd rails-example
            bundle exec bin/rails assets:precompile
            gcloud app deploy -q --no-promote --format=json > /tmp/railsdeploy.json
            cat /tmp/railsdeploy.json | jq -r .versions[0].id > /tmp/workspace/rails_target_version
            export TARGET_VERSION=$(cat /tmp/workspace/rails_target_version)
            # Store signature key and URL so that we can test it later on.
            echo ${SIGNATURE_KEY} > /tmp/workspace/rails_signature_key
            echo "https://${TARGET_VERSION}-dot-rails-dot-${GOOGLE_PROJECT_ID}.appspot.com/" > /tmp/workspace/rails_deploy_url
            # do db creation/migration here
            bundle exec rake appengine:exec GAE_SERVICE=rails GAE_VERSION=${TARGET_VERSION} -- bundle exec rake db:create db:migrate
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - rails_target_version
            - rails_deploy_url
            - rails_signature_key

  test-rails:
    docker:
      - image: circleci/ruby:2.5.3-stretch
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Test the app!
          command: |
            export SIGNATURE_KEY=$(cat /tmp/workspace/rails_signature_key)
            export TOKEN="$(cat /proc/sys/kernel/random/uuid)_$(date +%s)"
            export HASHED_TOKEN=$(echo -n "${SIGNATURE_KEY}_${TOKEN}" | sha256sum | awk '{print $1}')
            export AUTH_HEADER="ZAP-Authorization"
            export AUTH_INFO="${HASHED_TOKEN}_${TOKEN}"
            echo "run tests here against $(cat /tmp/workspace/rails_deploy_url) with an ${AUTH_HEADER} header"

  owaspzap-rails:
    docker:
      - image: owasp/zap2docker-weekly
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Run OWASP Zap against the app! (fails if the test takes more than 30 minutes)
          no_output_timeout: 30m
          command: |
            # if we are in production, do not do form posts, because they can potentially create cruft in the db.
            if [ "${CIRCLE_BRANCH}" = "master" ] ; then
              POSTFORM=false
            else
              POSTFORM=true
            fi
            # send special auth header that lets us scan
            export SIGNATURE_KEY=$(cat /tmp/workspace/rails_signature_key)
            export TOKEN="$(cat /proc/sys/kernel/random/uuid)_$(date +%s)"
            export HASHED_TOKEN=$(echo -n "${SIGNATURE_KEY}_${TOKEN}" | sha256sum | awk '{print $1}')
            export ZAP_CONFIG=" \
              -config globalexcludeurl.url_list.url\(0\).regex=.*/robots\.txt.* \
              -config globalexcludeurl.url_list.url\(0\).description='Exclude robots.txt' \
              -config globalexcludeurl.url_list.url\(0\).enabled=true \
              -config replacer.full_list\(0\).description='auth header for app' \
              -config replacer.full_list\(0\).enabled=true \
              -config replacer.full_list\(0\).matchtype=REQ_HEADER \
              -config replacer.full_list\(0\).matchstr=ZAP-Authorization \
              -config replacer.full_list\(0\).regex=false \
              -config replacer.full_list\(0\).replacement=${HASHED_TOKEN}_${TOKEN} \
              -config connection.defaultUserAgent='Mozilla/5.0 (Windows NT 6.3; WOW64; rv:39.0) Gecko/20100101 Firefox/39.0 ZAP/2.7' \
              -config spider.postform=${POSTFORM} \
            "
            if zap-full-scan.py -m 5 -z "${ZAP_CONFIG}" -t "$(cat /tmp/workspace/rails_deploy_url)" ; then
              echo "OWASP ZAP scan found no problems.  Yay!"
            else
              echo "XXX run a script or send email to notify Admins that the OWASP ZAP scan found issues here"
            fi

  promote-rails:
    docker:
      - image: google/cloud-sdk
    steps:
      - run:
          <<: *set-gcp-init-vars
      - run:
          <<: *initgcp-sdk
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Promote rails-example with sso to production
          command: |
            # promote rails
            export VERSION=$(cat /tmp/workspace/rails_target_version)
            gcloud app services set-traffic rails --splits ${VERSION}=1 --quiet
            echo promoted rails ${VERSION} to "https://rails-dot-${GOOGLE_PROJECT_ID}.appspot.com/"
      - run:
          name: Clean up old versions
          no_output_timeout: 30m
          command: |
            # clean up old versions (leave the last two, so you can roll back)
            VERSIONS=$(gcloud app versions list --service=rails --format=list | sort -rn | tail -n +3 | sed 's/^.*\///') || true
            if [ ! -z "${VERSIONS}" ] ; then
              gcloud app versions delete --service=rails ${VERSIONS} --quiet || true
              echo cleaned up rails ${VERSIONS}
            else
              echo no rails versions to clean up
            fi

#These are the workflows that define what CircleCI actually does.
workflows:
  version: 2
  build_and_deploy:
    jobs:
      - gcp_setup:
          filters:
            branches:
              only:
                # This is the list of branches which will trigger a terraform run.
                - master
                - staging
                - dev      
      - init_terraform_state:
          requires:
            - gcp_setup          
      - plan_terraform:
          requires:
            - init_terraform_state
      - apply_terraform:
          requires:
            - plan_terraform
      #Python Cloud SQL app jobs
      - deploy-py-postgres:
          requires:
            - plan_terraform      
          filters:
            branches:
              only:
                # This is the list of branches which will be deployed automatically.
                # Add more branches here if you want them automatically deployed.
                - master
                - staging
                - dev      
      - test-py-postgres:
          requires:
            - deploy-py-postgres  
      - owaspzap-py-postgres:
          requires:
            - test-py-postgres  
      - promote-py-postgres:
          requires:
            - owaspzap-py-postgres    
      #Rails app jobs
#      - deploy-rails:
#          requires:
#            - apply_terraform        
#          filters:
#            branches:
#              only:
#                # This is the list of branches which will be deployed automatically.
#                # Add more branches here if you want them automatically deployed.
#                # Their RAILS_ENV will get set to the branch name, or "production",
#                # if the branch is "master".
#                - master
#                - staging
#                - dev
#      - test-rails:
#          requires:
#            - deploy-rails
#      - owaspzap-rails:
#          requires:
#            - deploy-rails
#      - promote-rails:
#          requires:
#            - test-rails